// XUtil.tsx: utils specifically for React code

import React from 'react';

import {MAIN_TITLE} from './App';

// React libraries do not all agree on how to supply a single child.
// (in particular, react-markdown supplies [T] while react normally uses T)
export type SingleChild<T> = T | [T];
export function getSingleChild<T>(s: SingleChild<T>): T {
  if (Array.isArray(s)) {
    return s[0];
  }
  return s;
}

export function Title({children}: {children: SingleChild<string> | null}) {
  const title = children ? getSingleChild(children) : null;
  const prefix = title ? `${title} &mdash; ` : '';
  React.useEffect(() => {
    const $title = document.head.querySelector("title");
    if ($title) $title.innerHTML = `${prefix}${MAIN_TITLE}`;
  }, [prefix]);
  return null;
}

export function Wip({children}: {children: React.ReactNode}) {
  return <span data-wip="1">{children}</span>;
}
export function Wip2({children}: {children: React.ReactNode}) {
  return <span data-wip="2">{children}</span>;
}

/** useState but with a dependency list.  Not all overloads are supported. */
export function useDependentState<S>(
    initial: S,
    inputs: ReadonlyArray<any>,
    reset?: (prevState?: S) => S,
): [S, React.Dispatch<React.SetStateAction<S>>] {
  let [state, setState] = React.useState<S>(initial);

  // FIXME: Using useMemo for side-effects is wrong, and React reserves the right to break this.
  //        However, we can't change this to useEffect because we need it to happen NOW;
  //        useMemo and useCallback are the only ways to trigger code on the *current* render
  //        when a dependency has changed.
  //
  //        AFAICT, there is no hook that can fix this.  The only correct solution would be to reimplement
  //        React's dependency change check and use that to imperatively update `state` and call `setState`
  //        in the render function body.
  React.useMemo(() => {
    const newState = reset ? reset(state) : initial;
    if (newState !== state) {
      // Reassigning the local 'state' (used in our return value) is deliberate so that THIS render does not have a stale value.
      setState(state = newState); // eslint-disable-line
    }
  }, inputs);

  return [state, setState];
}

/**
 * Applies a "step" function to a state between each render and returns the current state.
 *
 * This can be used to help render something incrementally.  It is a generalization of useIncrementalCounter
 * for scenarios where working with a counter would be too arduous.
 *
 * The counter will always begin equal to `step`, and will reset to this value whenever the dependencies change.
 */
export function useIncremental<T>(
  kw: {
    init: T,
    step: (state: T) => T,
    stopWhen: (state: T) => boolean,
  },
  dependencies: ReadonlyArray<any>,
) {
  const {init, step, stopWhen} = kw;

  const [state, setState] = useDependentState(init, [...dependencies]);
  React.useEffect(() => {
    if (!stopWhen(state)) {
      const id = setTimeout(() => setState(step));
      return () => clearTimeout(id);
    }
    return undefined;
  }, [state, setState, step, stopWhen]);

  return state;
}

/**
 * Returns a counter that increases over subsequent renders, giving the browser a chance to update the DOM
 * each time using setTimeout.
 *
 * By e.g. trimming an array of child JSX elements to this length, you can use this to render a large page incrementally,
 * reducing the perceived time of page load by the user. (Note that `React.memo` may be necessary to avoid needlessly
 * rerendering children near the front).
 *
 * The counter will always begin equal to `step`, and will reset to this value whenever the dependencies change.
 */
export function useIncrementalCounter({step = 1, init = step, max = Infinity}: {step?: number, init?: number, max: number}, dependencies: ReadonlyArray<any>) {
  if (step === 0) {
    throw new Error("zero step!");
  }
  const stepFunction = React.useCallback((count) => Math.min(count + step, max), [step, max]);
  const stopWhen = React.useCallback((count) => count >= max, [max]);

  return useIncremental({init, step: stepFunction, stopWhen}, dependencies);
}

const DEFAULT_ID_PREFIX = '--autogenerated-id-';

/** Get a unique ID for a DOM element. */
export function useUniqueId(prefix = DEFAULT_ID_PREFIX): string {
  const [id] = React.useState(() => uniqueId(prefix));
  return id;
}

const uniqueId = (() => {
  let lastId = -1;
  return function uniqueId(prefix: string) {
    lastId++;
    return `${prefix}${lastId}`;
  };
})();


export function If({cond, children}: {cond: boolean, children: React.ReactNode}) {
  return (cond) ? <>{children}</> : null;
}

/**
 * A component that just forwards its ref to its only child.
 * This can let you apply a key to something without losing refs.
 **/
export const TrivialForwardRef = React.forwardRef(function TrivialForwardRef({children}: {children: JSX.Element}, ref: React.ForwardedRef<any>) {
  const child = React.Children.only(children);
  return <child.type ref={ref} {...child.props} />;
});
